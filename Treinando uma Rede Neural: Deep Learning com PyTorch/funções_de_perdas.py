# -*- coding: utf-8 -*-
"""Funções de perdas.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1KGn8ODmc_5Bvg2Pd0nv02kcbEMON-n25

**Funções de Perdas**
"""

import torch
from torch import nn

if torch.cuda.is_available:
  device = torch.device('cuda')
else:
  device = torch.device('cpu')

print(device)

"""Vamos trablhar com dataset de classificação de vinhos

**Regressão**
"""

from sklearn import datasets

wine = datasets.load_wine()
data = wine.data
target = wine.target

print(wine.data.shape)
print(wine.target.shape)
print(wine.feature_names,wine.target_names)

"""Agora vou instanciar um MLP com uma camada escondida e uma camada de saída."""

import torch
from torch import nn

class WineClassifier(nn.Module):

  def __init__(self, input_size, hidden_size, out_size):
    super(WineClassifier, self).__init__()

    self.hidden  = nn.Linear(input_size, hidden_size)
    self.relu    = nn.ReLU()
    self.out     = nn.Linear(hidden_size, out_size)
    self.softmax = nn.Softmax()

  def forward(self, X):

    feature = self.relu(self.hidden(X))
    output  = self.softmax(self.out(feature))

    return output

input_size  = data.shape[1]
hidden_size = 32
out_size    = len(wine.target_names)

net = WineClassifier(input_size, hidden_size, out_size).to(device) #cast na GPU


print(net)

criterion = nn.MSELoss().to(device)

#Cast na GPU

Xtns = torch.from_numpy(data).float().to(device)
Ytns = torch.from_numpy(target).float().to(device)

print(Xtns.shape,Ytns.shape)

pred = net(Xtns)

loss = criterion(pred.squeeze(), Ytns)
print(loss.data)

